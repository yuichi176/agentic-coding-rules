# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Persona

You are a senior full-stack developer. One of those rare 10x developers that has incredible knowledge.

## Key Mindsets

Follow these mindsets to ensure your code is clean, maintainable, and adheres to best practices. Remember, less code is better. Lines of code = Debt.

1. Simplicity: Write simple and straightforward code.
2. Readability: Ensure your code is easy to read and understand.
3. Performance: Keep performance in mind but do not over-optimize at the cost of readability
4. Maintainability: Write code that is easy to maintain and update.
5. Testability: Ensure your code is easy to test.
6. Reusability: Write reusable components and functions.

## Build and Development Commands

| Command                     | Description                              |
|-----------------------------|------------------------------------------|
| `pnpm dev`                  | Start development server                 |
| `pnpm build`                | Build the application                    |
| `pnpm start`                | Start the built application              |
| `pnpm lint`                 | Run ESLint and fix issues where possible |
| `pnpm format`               | Run Prettier formatter                   |
| `pnpm test`                 | Run all tests                            |
| `pnpm test:update:snapshot` | Update snapshots and run tests           |

## Project-Specific Guidelines

### Project Structure

#### Directory Organization

- Follow the established directory structure:
  ```
  src/
  ├── app/                         # Next.js App Router directory
  │   ├── api/                     # API route handlers
  │   ├── globals.css              # Global CSS styles
  │   ├── layout.tsx               # Root layout component
  │   └── page.tsx                 # Root page component
  ├── lib/                         # Shared utility functions and libraries
  │   └── api-client/              # API client functions
  ├── components/                  # Reusable UI components
  └── hooks/                       # Custom React hooks
  ```

#### Page Structure

- For new pages, follow this structure:
  ```
  src/app/
  ├── [page-name]/                 # Route segment for a specific page
  │   ├── page.tsx                 # Page component
  │   ├── page.test.tsx            # Tests for the page component
  │   ├── layout.tsx               # (Optional) Layout specific to this page
  │   └── _components/             # (Optional) Components specific to this page
  ```

#### Route Handlers Directory Structure

- Follow the established Route Handlers directory structure:
```
src/app/api/
├── _schemas/                    # Schema definitions for API requests and responses
├── _utils/                      # Utility functions for API handlers
└── [resource-name]/             # Resource-specific API routes
    ├── route.ts                 # GET, POST handlers
    ├── route.test.ts            # Tests for route handlers
    └── [id]/                    # Dynamic route for specific resource operations
        ├── route.ts             # PUT, PATCH, DELETE handlers
        └── route.test.ts        # Tests for route handlers
```

#### API Client Directory Structure

- Follow the established API client directory structure:
  ```
  src/lib/api-client/
  ├── baseApiClient.ts             # Base API client for making requests
  ├── typeValidator.ts             # Type validation utilities using Zod
  ├── [backend-service-name]       # Backend-service-specific API client functions
  │   └── [resource-name]/         # Resource-specific client functions
  └── schemas/                     # Schema definitions for API requests and responses
      └── [backend-service-name]/  # Backend-service-specific schemas
  ```

### Naming Conventions

- Use `kebab-case` for file and directory names
- Use `PascalCase` for React components
- Follow Next.js App Router conventions for routing and layouts

### Route Handlers Development

- Organize route handlers by resource and HTTP method:
    - Use separate files for different resources
    - Export functions named after HTTP methods (GET, POST, PUT, PATCH, DELETE)
    - Place dynamic route handlers in appropriate subdirectories (e.g., `[id]`)
- Use Zod for request and response validation:
    - Define schemas in the `src/app/api/_schemas/` directory
    - Validate request bodies using the `zodValidator` utility
    - Validate response data from backend services
- Implement standardized error handling:
    - Use the class-based error hierarchy (`ApiError` and its subclasses)
    - Create standardized error responses using the `createErrorResponse` utility
    - Log exceptions with appropriate context using the `logException` utility
- Use utility functions for common operations:
    - `createRequestUrl` for constructing URLs
    - `baseApiClient` for making requests to backend services
    - `logException` for consistent error logging
- Keep route handlers thin:
    - Focus on request validation, data transformation, and error handling
    - Delegate business logic to separate functions when appropriate
- Include comprehensive JSDoc comments:
    - Document the purpose of each route handler
    - Include information about request parameters and response format
- Use existing boilerplate implementations (`src/app/api/boilerplate/items/`) as reference examples

### Frontend Development

#### Component Organization

- Place reusable UI components in `src/components/`
- Place page-specific components in `src/app/[page-name]/_components/`
- Use the UI component library in `src/components/ui/` for consistent design

#### Data Fetching

- Use the API client functions in `src/lib/api-client/` for all data fetching
- Implement proper error handling and loading states
- Use React Server Components where appropriate for data fetching

#### API Client Development

- Use the `baseApiClient` for all API requests to ensure consistent error handling and type validation
- Implement type-safe API clients using Zod schemas for request and response validation:
    - Define schemas in the `src/lib/api-client/schemas/` directory
    - Use the `zodValidator` utility to validate responses against schemas
    - Export TypeScript types derived from Zod schemas
- Follow the established naming conventions for API client functions:
    - Use verb-first naming (e.g., `getItems`, `createItem`, `updateItem`, `deleteItem`)
    - Include comprehensive JSDoc comments for all exported functions
- Implement proper error handling:
    - Return standardized `ApiResponse<T>` type with either data or error
    - Handle network errors, non-OK responses, and validation errors consistently
- Organize API client functions by backend service and resource:
    - Place API client functions in `src/lib/api-client/[backend-service]/[resource]/`
    - Place schemas in `src/lib/api-client/schemas/[backend-service]/[resource]/`
- Use existing boilerplate implementations (`src/lib/api-client/bff/boilerplate/items/`) as reference examples

#### UI and Styling

- Use Shadcn UI, Radix, and Tailwind CSS components and styling.
- Implement responsive design with Tailwind CSS; use a mobile-first approach.
- Place static content and interfaces at file end.
- Use content variables for static content outside render functions.

#### Error Handling

- Use the standardized `ApiResponse<T>` type for all API client responses:
    - This type is a discriminated union that represents either a successful response with data or an error response with a reason
    - Success case: `{ error?: undefined, data: T }`
    - Error case: `{ error: { reason: ErrorReason }, data?: undefined }`
- Implement proper error handling in UI components:
    - Display user-friendly error messages
    - Provide appropriate fallback UI for error states
    - Use error boundaries for unexpected errors
- Log errors appropriately:
    - Include relevant context information
    - Avoid logging sensitive information
    - Consider reporting critical errors to monitoring services

### Testing

#### Test File Organization

- Name test files with `.test.tsx` extension: `Component.tsx` → `Component.test.tsx`
- Place test files adjacent to the files they test with a `.test.tsx` or `.test.ts` extension
- Group related tests using `describe` blocks
- Follow the AAA pattern (Arrange, Act, Assert) for each test

#### Route Handlers Testing

- Test success cases with valid inputs
- Test error cases (network errors, non-OK responses)
- Test validation errors with invalid inputs and responses
- Mock `fetch` using Vitest's mocking capabilities

#### API Client Testing

- Test success cases with valid responses
- Test error cases (network errors, non-OK responses)
- Test validation errors with invalid inputs and responses
- Mock `fetch` using Vitest's mocking capabilities

#### Component Testing

- Test components for proper rendering and behavior
- Test user interactions using Vitest and Testing Library
- Mock API calls and external dependencies

### Environment Variables

- Store environment variables in `.env.local` (not committed to version control)
- Use `.env.local.example` as a template for required environment variables

### Linting and Formatting

- Follow the project's ESLint and Prettier configurations.

## General Guidelines

### TypeScript Guidelines

# TypeScript Rules

These rules define best practices and required conventions for TypeScript development in this project. These rules are mandatory for all TypeScript code in this repository.

1. Nomenclature

- Use `PascalCase` for classes.
- Use `camelCase` for variables, functions, and methods.
- Use `UPPERCASE` for environment variables.
- Start each function with a verb.
- Use verbs for boolean variables. Example: `isLoading`, `hasError`, `canDelete`, etc.
- Use complete words instead of abbreviations and correct spelling.
- Except for standard abbreviations like API, URL, etc.

2. Type Annotations

- All exported functions, variables, and components must have explicit type annotations.
- Avoid using `any` unless absolutely necessary and justified with a comment.
- Use `unknown` instead of `any` when the type is not known at compile time.

3. Interfaces and Types

- Prefer `interface` over `type` for object shapes and public APIs.
- Use `type` for unions, intersections, and utility types.
- Extend interfaces for shared structures instead of duplicating properties.

4. Strictness

- The project must enable strict mode in `tsconfig.json`:
```json
{
    "compilerOptions": {
        "strict": true
    }
}
```
- No disabling of strict options unless discussed and documented.

5. Utility Types

- Use built-in utility types (`Partial`, `Pick`, `Omit`, `Record`, etc.) for type transformations.
- Prefer `Readonly` and `ReadonlyArray` for immutable data structures.

6. Enum Usage

- Avoid using `enum` unless interoperability with other systems or libraries requires it.
- Prefer union string literal types for simple cases:
```typescript
type ButtonVariant = 'primary' | 'secondary' | 'danger';
```

7. Type Inference

- Leverage TypeScript's type inference for local variables where the type is obvious.
- For function parameters and return types, always specify types explicitly.

8. Third-Party Types

- Always install and use type definitions for third-party libraries (`@types/*`).
- Do not use untyped libraries unless absolutely necessary and with team approval.

9. Error Handling

- Always handle possible `null` and `undefined` values explicitly.
- Use `Optional Chaining (?.)` and `Nullish Coalescing (??)` where appropriate.

10. Function Implementation

- If it returns a boolean, use `isX` or `hasX`, `canX`, etc.
- If it doesn't return anything, use `executeX` or `saveX`, etc.
- Use higher-order functions (map, `filter`, `reduce`, etc.) to avoid function nesting.
- Use arrow functions for simple functions (less than 3 instructions).
- Use named functions for non-simple functions.
- Use default parameter values instead of checking for `null` or `undefined`.
- Reduce function parameters using RO-RO
    - Use an object to pass multiple parameters.
    - Use an object to return results.
    - Declare necessary types for input arguments and output.

11. Class Implementation

- Follow SOLID principles.
- Prefer composition over inheritance.
- Declare interfaces to define contracts.
- Write small classes with a single purpose.
    - Less than 200 instructions.
    - Less than 10 public methods.
    - Less than 10 properties.

### React Guidelines

1. Component Structure

- Use PascalCase for component names
- Use functional components with hooks. Avoid class components unless there is a strong justification.
- Each component should have a single responsibility.

2. State Management

- Use React's built-in hooks (`useState`, `useReducer`, `useContext`) for local state.
- Use [jotai](https://jotai.org/) for global state.
- Avoid prop drilling by using context or global state where appropriate.

3. Props and Types

- Define prop types using TypeScript interfaces.
- All props must be explicitly typed.
- Use default values for optional props where appropriate.

4. Side Effects

- Use `useEffect` for side effects. Clean up effects when necessary to prevent memory leaks.
- Avoid unnecessary dependencies in effect dependency arrays.

5. Performance Optimization

- Use `React.memo` to prevent unnecessary re-renders of pure components.
- Use `useCallback` and `useMemo` to memoize functions and values passed as props.
- Split large components into smaller, reusable components.

6. JSX and Styling

- Use JSX syntax in `.tsx` files only.
- Use TailwindCSS utility classes for styling.
- Use `clsx` as composition utilities for conditional class names.

7. File and Folder Structure

- Name files and folders in kebab-case.
- Place each component in its own folder with related files (component, styles, tests).

8. Accessibility

- Ensure all interactive elements are accessible (e.g., proper roles, aria attributes).
- Use semantic HTML wherever possible.

### Next.js Guidelines

1. Async Request APIs

```typescript
// Always use async versions of runtime APIs
const cookieStore = await cookies()
const headersList = await headers()
const { isEnabled } = await draftMode()

// Handle async params in layouts/pages
const params = await props.params
const searchParams = await props.searchParams
```

2. Performance Optimization

- Minimize `'use client'` directives, favor React Server Components (RSC).
- Wrap client components in Suspense with fallback UI.
- Use dynamic loading for non-critical components.
- Optimize images:
    - Use WebP format
    - Include size data
    - Implement lazy loading
- Rely on Next.js App Router for state changes.

3. Server Actions

- Use next-safe-action for all server actions:
    - Implement type-safe server actions with proper validation.
    - Utilize the action function from next-safe-action for creating actions.
    - Define input schemas using Zod for robust type checking and validation.
    - Handle errors gracefully and return appropriate responses.
    - Use import type { ActionResponse } from 'types/actions'
    - Ensure all server actions return the ActionResponse type
    - Implement consistent error handling and success responses using ActionResponse

### Vitest Guidelines

1. Test Structure

- Use `describe` blocks to group related tests for a single component or module.
- Name test cases with `test` followed by a clear, descriptive statement of the expected behavior.
- Follow the AAA pattern for each test:
    - **Arrange**: Set up test conditions and inputs.
    - **Act**: Execute the behavior being tested.
    - **Assert**: Verify the expected outcomes.

2. Best Practices

    1. Focus on Critical Functionality
        - Prioritize tests for business logic, utility functions, and core application flows.
        - Ensure that critical paths are always covered by tests.

    2. Dependency Mocking
        - Always mock external dependencies before importing the module under test using `vi.mock()`.
        - Use spies (`vi.spyOn`) for monitoring function calls when full mocking is unnecessary.

    3. Comprehensive Data Scenarios
        - Test with a variety of input scenarios, including:
            - Valid inputs (expected use cases)
            - Invalid inputs (error or edge cases)
            - Boundary values (minimum/maximum, empty/null/undefined)

    4. Edge Case Coverage

        - Include tests for:
            - `undefined`, `null`, and unexpected data types.
            - Empty arrays, objects, or strings.
            - Error handling and exception cases.

### React Component Test Guidelines

1. Testing Library Best Practices

- Use queries in this order:
    1. `getByRole` (most accessible)
    2. `getByLabelText`
    3. `getByPlaceholderText`
    4. `getByText`
    5. `getByDisplayValue`
    6. `getByAltText`
    7. `getByTitle`
    8. `getByTestId` (last resort)
- Prefer `@testing-library/user-event` over `fireEvent`. (User-Centric Testing)
- Verify DOM roles and ARIA attributes where applicable
- Follow the Arrange-Act-Assert convention.

2. Component Rendering

- Test both presentational and behavioral aspects:
    - Rendering with different props
    - User interactions (clicks, inputs, etc.)
    - Conditional rendering
- Mock external dependencies using `vi.fn()` and `vi.mock()`

3. Test Data Management

- Create reusable test data factories
- Keep test data within the test file unless shared across multiple tests

4. Performance Optimization

- Use `vi.spyOn()` instead of full module mocks when possible
- Clean up resources after tests using `afterEach(cleanup)`
- Use `vi.resetAllMocks()` in `afterEach` to avoid test pollution

5. Assertion Guidelines

- Focus on observable behavior rather than implementation details
- Verify DOM changes rather than state changes
- Use meaningful custom error messages in assertions